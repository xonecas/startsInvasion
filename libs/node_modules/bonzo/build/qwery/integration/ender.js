/*!
  * Ender: open module JavaScript framework
  * copyright Dustin Diaz & Jacob Thornton 2011 (@ded @fat)
  * https://github.com/ender-js/ender
  * License MIT
  * Build: ender build domready bonzo
  */
!function (context) {

  function aug(o, o2) {
    for (var k in o2) {
      k != 'noConflict' && (o[k] = o2[k]);
    }
  }

  function _$(s, r) {
    this.elements = typeof s !== 'string' && !s.nodeType && typeof s.length !== 'undefined' ? s : $._select(s, r);
    this.length = this.elements.length;
    for (var i = 0; i < this.length; i++) {
      this[i] = this.elements[i];
    }
  }

  function $(s, r) {
    return new _$(s, r);
  }

  aug($, {
    ender: function (o, proto) {
      aug(proto ? _$.prototype : $, o);
    },
    _select: function () {
      return [];
    }
  });

  var old = context.$;
  $.noConflict = function () {
    context.$ = old;
    return this;
  };

  (typeof module !== 'undefined') && module.exports ?
    (module.exports = $) :
    (context.$ = $);

}(this);
!function () { var exports = {}, module = { exports: exports }; !function (doc) {
  var loaded = 0, fns = [], ol, f = false,
      testEl = doc.createElement('a'),
      domContentLoaded = 'DOMContentLoaded',
      addEventListener = 'addEventListener',
      onreadystatechange = 'onreadystatechange';

  /^loade|c/.test(doc.readyState) && (loaded = 1);

  function flush() {
    loaded = 1;
    for (var i = 0, l = fns.length; i < l; i++) {
      fns[i]();
    }
  }
  doc[addEventListener] && doc[addEventListener](domContentLoaded, function fn() {
    doc.removeEventListener(domContentLoaded, fn, f);
    flush();
  }, f);


  testEl.doScroll && doc.attachEvent(onreadystatechange, (ol = function ol() {
    if (/^c/.test(doc.readyState)) {
      doc.detachEvent(onreadystatechange, ol);
      flush();
    }
  }));

  var domReady = testEl.doScroll ?
    function (fn) {
      self != top ?
        !loaded ?
          fns.push(fn) :
          fn() :
        !function () {
          try {
            testEl.doScroll('left');
          } catch (e) {
            return setTimeout(function() {
              domReady(fn);
            }, 50);
          }
          fn();
        }();
    } :
    function (fn) {
      loaded ? fn() : fns.push(fn);
    };

    (typeof module !== 'undefined') && module.exports ?
      (module.exports = {domReady: domReady}) :
      (window.domReady = domReady);

}(document); $.ender(module.exports); }();
/*!
  * bonzo.js - copyright @dedfat 2011
  * https://github.com/ded/bonzo
  * Follow our software http://twitter.com/dedfat
  * MIT License
  */
!function (context) {

  var doc = document,
      html = doc.documentElement,
      specialAttributes = /^checked|value|selected$/,
      stateAttributes = /^checked|selected$/,
      ie = /msie/.test(navigator.userAgent),
      uidList = [],
      uuids = 0;

  function classReg(c) {
    return new RegExp("(^|\\s+)" + c + "(\\s+|$)");
  }

  function each(ar, fn) {
    for (i = 0, len = ar.length; i < len; i++) {
      fn(ar[i]);
    }
  }

  function trim(s) {
    return s.replace(/(^\s*|\s*$)/g, '');
  }

  function camelize(s) {
    return s.replace(/-(.)/g, function (m, m1) {
      return m1.toUpperCase();
    });
  }

  function is(node) {
    return node && node.nodeName && node.nodeType == 1;
  }

  function some(ar, fn, scope) {
    for (var i = 0, j = ar.length; i < j; ++i) {
      if (fn.call(scope, ar[i], i, ar)) {
        return true;
      }
    }
    return false;
  }

  function sucks(o) {
    for (var k in o) {
      switch (k) {
      case 'opacity':
        o.filter = 'alpha(opacity=' + (o[k] * 100) + ')';
        delete o[k];
        break;
      case '':
        break;
      }
    }
  }

  function _bonzo(elements) {
    this.elements = [];
    this.length = 0;
    if (elements) {
      this.elements = typeof elements !== 'string' && !elements.nodeType && typeof elements.length !== 'undefined' ? elements : [elements];
      this.length = this.elements.length;
      for (var i = 0; i < this.length; i++) {
        this[i] = this.elements[i];
      }
    }
  }

  _bonzo.prototype = {

    each: function (fn) {
      for (var i = 0, l = this.length; i < l; i++) {
        fn.call(this, this[i], i);
      }
      return this;
    },

    map: function (fn, reject) {
      var m = [], n;
      for (var i = 0; i < this.length; i++) {
        n = fn.call(this, this[i]);
        reject ? (reject(n) && m.push(n)) : m.push(n);
      }
      return m;
    },

    first: function () {
      return bonzo(this[0]);
    },

    last: function () {
      return bonzo(this[this.length - 1]);
    },

    html: function (html) {
      return typeof html !== 'undefined' ?
        this.each(function (el) {
          el.innerHTML = html;
        }) :
        this.elements[0] ? this.elements[0].innerHTML : '';
    },

    addClass: function (c) {
      return this.each(function (el) {
        this.hasClass(el, c) || (el.className = trim(el.className + ' ' + c));
      });
    },

    removeClass: function (c) {
      return this.each(function (el) {
        this.hasClass(el, c) && (el.className = trim(el.className.replace(classReg(c), ' ')));
      });
    },

    hasClass: function (el, c) {
      return typeof c == 'undefined' ?
        some(this.elements, function (i) {
          return classReg(el).test(i.className);
        }) :
        classReg(c).test(el.className);
    },

    toggleClass: function (c, condition) {
      if (typeof condition !== 'undefined' && !condition) {
        return this;
      }
      return this.each(function (el) {
        this.hasClass(el, c) ?
          (el.className = trim(el.className.replace(classReg(c), ' '))) :
          (el.className = trim(el.className + ' ' + c));
      });
    },

    show: function (elements) {
      return this.each(function (el) {
        el.style.display = '';
      });
    },

    hide: function (elements) {
      return this.each(function (el) {
        el.style.display = 'none';
      });
    },

    append: function (node) {
      return this.each(function (el) {
        each(normalize(node), function (i) {
          el.appendChild(i);
        });
      });
    },

    prepend: function (node) {
      return this.each(function (el) {
        var first = el.firstChild;
        each(normalize(node), function (i) {
          el.insertBefore(i, first);
        });
      });
    },

    appendTo: function (target) {
      return this.each(function (el) {
        target.appendChild(el);
      });
    },

    next: function () {
      return this.related('nextSibling');
    },

    previous: function () {
      return this.related('previousSibling');
    },

    related: function (method) {
      return this.map(
        function (el) {
          el = el[method];
          while (el && el.nodeType !== 1) {
            el = el[method];
          }
          return el || 0;
        },
        function (el) {
          return el;
        }
      );
    },

    prependTo: function (target) {
      return this.each(function (el) {
        target.insertBefore(el, bonzo.firstChild(target));
      });
    },

    before: function (node) {
      return this.each(function (el) {
        each(bonzo.create(node), function (i) {
          el.parentNode.insertBefore(i, el);
        });
      });
    },

    insertBefore: function (node) {
      return this.each(function (el) {
        each(normalize(node), function (n) {
          n.parentNode.insertBefore(el, n);
        });
      });
    },

    insertAfter: function (node) {
      return this.each(function (el) {
        each(normalize(node), function (n) {
          n.parentNode.insertBefore(el, (n.nextSibling || n));
        });
      });
    },

    after: function (node) {
      return this.each(function (el) {
        each(bonzo.create(node), function (i) {
          el.parentNode.insertBefore(i, el.nextSibling);
        });
      });
    },

    css: function (o, v) {
      if (v === undefined && typeof o == 'string') {
        return this[0].style[camelize(o)];
      }
      var iter = o;
      if (typeof o == 'string') {
        iter = {};
        iter[o] = v;
      }
      ie && sucks(iter);
      var fn = function (el) {
        for (var k in iter) {
          iter.hasOwnProperty(k) && (el.style[camelize(k)] = iter[k]);
        }
      };
      return this.each(fn);
    },

    offset: function () {
      var el = this.elements[0];
      var width = el.offsetWidth;
      var height = el.offsetHeight;
      var top = el.offsetTop;
      var left = el.offsetLeft;
      while (el = el.offsetParent) {
        top = top + el.offsetTop;
        left = left + el.offsetLeft;
      }

      return {
        top: top,
        left: left,
        height: height,
        width: width
      };
    },

    attr: function (k, v) {
      var el = this.elements[0];
      return typeof v == 'undefined' ?
        specialAttributes.test(k) ?
          stateAttributes.test(k) && typeof el[k] == 'string' ?
            true : el[k] : el.getAttribute(k) :
        this.each(function (el) {
          el.setAttribute(k, v);
        });
    },

    removeAttr: function (k) {
      return this.each(function (el) {
        el.removeAttribute(k);
      });
    },

    data: function (k, v) {
      var el = this.elements[0];
      if (typeof v === 'undefined') {
        el.getAttribute('data-node-uid') || el.setAttribute('data-node-uid', ++uuids);
        var uid = el.getAttribute('data-node-uid');
        uidList[uid] || (uidList[uid] = {});
        return uidList[uid][k];
      } else {
        return this.each(function (el) {
          el.getAttribute('data-node-uid') || el.setAttribute('data-node-uid', ++uuids);
          var uid = el.getAttribute('data-node-uid');
          var o = {};
          o[k] = v;
          uidList[uid] = o;
        });
      }
    },

    remove: function () {
      return this.each(function (el) {
        el.parentNode && el.parentNode.removeChild(el);
      });
    },

    empty: function () {
      return this.each(function (el) {
        while (el.firstChild) {
          el.removeChild(el.firstChild);
        }
      });
    },

    detach: function () {
      return this.map(function (el) {
        return el.parentNode.removeChild(el);
      });
    },

    scrollTop: function (y) {
      return scroll.call(this, null, y, 'y');
    },

    scrollLeft: function (x) {
      return scroll.call(this, x, null, 'x');
    },

    serialize: function () {
      var form = this[0],
          inputs = form.getElementsByTagName('input'),
          selects = form.getElementsByTagName('select'),
          texts = form.getElementsByTagName('textarea');
      return (bonzo(inputs).map(serial).join('') +
      bonzo(selects).map(serial).join('') +
      bonzo(texts).map(serial).join('')).replace(/&$/, '');
    },

    serializeArray: function () {
      for (var pairs = this.serialize().split('&'), i = 0, l = pairs.length, r = [], o; i < l; i++) {
        pairs[i] && (o = pairs[i].split('=')) && r.push({name: o[0], value: o[1]});
      }
      return r;
    }
  };

  function enc(v) {
    return encodeURIComponent(v);
  }

  function serial(el) {
    var n = el.name;
    // don't serialize elements that are disabled or without a name
    if (el.disabled || !n) {
      return '';
    }
    n = enc(n);
    switch (el.tagName.toLowerCase()) {
    case 'input':
      switch (el.type) {
      case 'reset':
      case 'button':
      case 'image':
      case 'file':
        return '';
      case 'checkbox':
      case 'radio':
        return el.checked ? n + '=' + (el.value ? enc(el.value) : true) + '&' : '';
      default: // text hidden password submit
        return n + '=' + (el.value ? enc(el.value) : true) + '&';
      }
      break;
    case 'textarea':
      return n + '=' + enc(el.value) + '&';
    case 'select':
      // @todo refactor beyond basic single selected value case
      return n + '=' + enc(el.options[el.selectedIndex].value) + '&';
    }
    return '';
  }

  function normalize(node) {
    return typeof node == 'string' ? bonzo.create(node) : is(node) ? [node] : node;
  }

  function scroll(x, y, type) {
    var el = this.elements[0];
    if (x == null && y == null) {
      return (isBody(el) ? getWindowScroll() : { x: el.scrollLeft, y: el.scrollTop })[type];
    }
    if (isBody(el)) {
      window.scrollTo(x, y);
    } else {
      x != null && (el.scrollLeft = x);
      y != null && (el.scrollTop = y);
    }
    return this;
  }

  function isBody(element) {
    return element === window || (/^(?:body|html)$/i).test(element.tagName);
  }

  function getWindowScroll() {
    return { x: window.pageXOffset || html.scrollLeft, y: window.pageYOffset || html.scrollTop };
  }

  function bonzo(els) {
    return new _bonzo(els);
  }

  bonzo.aug = function (o, target) {
    for (var k in o) {
      o.hasOwnProperty(k) && ((target || _bonzo.prototype)[k] = o[k]);
    }
  };

  bonzo.create = function (node) {
    return typeof node == 'string' ?
      function () {
        var el = doc.createElement('div'), els = [];
        el.innerHTML = node;
        var nodes = el.childNodes;
        el = el.firstChild;
        els.push(el);
        while (el = el.nextSibling) {
          (el.nodeType == 1) && els.push(el);
        }
        return els;

      }() : is(node) ? [node.cloneNode(true)] : [];
  };

  bonzo.doc = function () {
    var w = html.scrollWidth,
        h = html.scrollHeight,
        vp = this.viewport();
    return {
      width: Math.max(w, vp.width),
      height: Math.max(h, vp.height)
    };
  };

  bonzo.firstChild = function (el) {
    for (var c = el.childNodes, i = 0, j = (c && c.length) || 0, e; i < j; i++) {
      if (c[i].nodeType === 1) {
        e = c[j = i];
      }
    }
    return e;
  };

  bonzo.viewport = function () {
    var h = self.innerHeight,
        w = self.innerWidth;
    ie && (h = html.clientHeight) && (w = html.clientWidth);
    return {
      width: w,
      height: h
    };
  };

  bonzo.isAncestor = 'compareDocumentPosition' in html ?
    function (container, element) {
      return (container.compareDocumentPosition(element) & 16) == 16;
    } : 'contains' in html ?
    function (container, element) {
      return container !== element && container.contains(element);
    } :
    function (container, element) {
      while (element = element.parentNode) {
        if (element === container) {
          return true;
        }
      }
      return false;
    };

  var old = context.bonzo;
  bonzo.noConflict = function () {
    context.bonzo = old;
    return this;
  };
  context.bonzo = bonzo;

}(this);!function () {
  var b = bonzo.noConflict();
  $.ender(b);
  $.ender(b(), true);
  $.ender({
    create: function (node) {
      return $(b.create(node));
    }
  });

  function indexOf(ar, val) {
    for (var i = 0; i < ar.length; i++) {
      if ( ar[i] === val ) {
        return i;
      }
    }
    return -1;
  }

  function uniq(ar) {
    var a = [], i, j;
    label:
    for (i = 0; i < ar.length; i++) {
      for (j = 0; j < a.length; j++) {
        if (a[j] == ar[i]) {
          continue label;
        }
      }
      a[a.length] = ar[i];
    }
    return a;
  }
  $.ender({
    parents: function (selector, closest) {
      var collection = $(selector), j, k, p, r = [];
      for (j = 0, k = this.length; j < k; j++) {
        p = this[j];
        while (p = p.parentNode) {
          if (indexOf(collection, p) !== -1) {
            r.push(p);
            if (closest) break;
          }
        }
      }
      return $(uniq(r));
    },

    closest: function (selector) {
      return this.parents(selector, true);
    },

    first: function () {
      return $(this[0]);
    },

    last: function () {
      return $(this[this.length - 1]);
    },

    next: function () {
      return $(b(this).next());
    },

    previous: function () {
      return $(b(this).previous());
    },

    siblings: function () {
      var i, l, p, r = [];
      for (i = 0, l = this.length; i < l; i++) {
        p = this[i];
        while (p = p.previousSibling) {
          p.nodeType == 1 && r.push(p);
        }
        p = this[i];
        while (p = p.nextSibling) {
          p.nodeType == 1 && r.push(p);
        }
      }
      return $(uniq(r));
    }
  }, true);

}();
